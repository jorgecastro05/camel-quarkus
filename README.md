# camel-quarkus Base project

This is my personal project, uses Quarkus, the Supersonic Subatomic Java Framework and camel Integration framework

If you want to learn more about Quarkus, please visit its website: https://quarkus.io/ .

## Running the application in dev mode

You can run your application in dev mode that enables live coding using `./mvnw quarkus:dev`


## Packaging and running the application

The application can be packaged using `./mvnw package`. 
It produces the `camel-quarkus-1.0.0-SNAPSHOT-runner.jar` file in the `/target` directory.
Be aware Lang it’s not an _über-jar_ as the dependencies are copied into the `target/lib` directory.
The application is now runnable using `java -jar target/camel-quarkus-1.0.0-SNAPSHOT-runner.jar`.

## Creating a native executable

1. Install GraalVM, you can install easily with SDKMAN - https://sdkman.io/

2. Install the prerequisites with graal `gu install native-image`, 
then install the compiler libraries for especific operating system, for example in fedora 
`sudo dnf install gcc-c++ zlib-devel` 

3. create a native executable using: `./mvnw package -Pnative`.

4. You can then execute your native executable with: `./target/camel-quarkus-1.0.0-SNAPSHOT-runner`

*Or, if you don't have GraalVM installed, you can run the native executable build in a container using: `./mvnw package -Pnative -Dquarkus.native.container-build=true`. 
**Note** (this require a docker daemon running in the host machine).*

## Deploy to Openshift with JVM docker Image

1. Set the property `<jkube.generator.quarkus.nativeImage>true</jkube.generator.quarkus.nativeImage>` 
to false in the pom.xml file

2. use this command to deploy on Openshift `mvn clean package oc:build oc:resource oc:apply` 
or this command `mvn clean install`
    
## Deploy openshift with Native docker image

This project creates native images by default, use this goal to deploy the application 
all in one, (with the prerequisites to build native executable already).

    mvn clean package oc:build oc:resource oc:apply -Pnative


## Useful commands for deploying quarkus applications 

- Creating image natives and pushing into quay.io

    ~~~
    podman build -f src/main/docker/Dockerfile.native -t camel-quarkus .
    podman login quay.io
    podman push camel-quarkus docker://quay.io/{userquay}/camel-quarkus
    ~~~
    
- Creating the deployment config from the uploaded native image
    
  `oc new-app --name quarkus-native --docker-image quay.io/jorgecastro05/camel-quarkus`

- Creating kubernetes deployments from the upload native image
    
    ~~~
    kubectl create deployment quarkus-native --image=quay.io/jorgecastro05/camel-quarkus
    kubectl set env deployment quarkus-native DISABLE_SIGNAL_HANDLERS="true"
    ~~~

- Exposing kubenetes applications
    ~~~
    kubectl expose deployment quarkus-native --type=NodePort --port=8080
    kubectl get svc
    ~~~

- Check the random port generated by kubernetes and test ex `curl http://localhost:30652/swagger-ui/`

    NAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
    quarkus-native     NodePort   10.43.242.183   <none>        8080:30652/TCP   3s
   
## Load Openshift console into eclipse che

Execute the task download and configure oc, then open a new terminal and execute the following command

     export PATH=$PATH:$(pwd)/oc-console

    
    

